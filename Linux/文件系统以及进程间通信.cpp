utf-8  中文占3个字节
		系统调用IO接口：
			open    O_RDONLY  0_WRONLY O_RDWR | O_CREAT|O_EXCL|O_TRUNC|O_APPEND
			write   read  返回实际读写的长度  lseek   close----------int

			文件描述符和文件流指针
				文件流指针中包含了一个成员变量---文件描述符
				库函数内部封装的就是系统调用接口

			缓冲区：
				文件流指针中的，系统调用的不需要缓冲区

				缓冲区是用户态的缓冲区，存在于文件流指针结构体中

				文件描述符：系统调用的句柄(是一个数组下标，指向进程中的文件状态信息表中的文件描述信息)
				文件描述符分配规则：最小未使用
				重定向：文件描述符的重定向---改变描述符对应的描述信息，进而改变操作的文件，但是描述符不变

				minishell的重定向: >清空重定向   >>追加重定向
				解析字符串，获取命令名称+参数,在参数中判断是否包含> >>,在重定向符号下一个元素（文件名称）按照相应重定向类型打开文件

						dup2(old,new)

		文件系统：磁盘中的文件管理，以linux下的ext2为例
				每个分区中都有一个文件系统，管理文件
				分页内存管理：分成内存块，每个大小4096
				ps：进程资源使用
				top：CPU资源使用情况
				df：查看磁盘分区资源使用情况
				free：查看内存资源使用情况
				fdisk -l :查看磁盘使用情况
				硬盘接口类型：
						SATA：命名方式：sda
						IDE:
						SCSI:
						NVME: 常用固态硬盘接口类型
				磁盘扇区大小：硬盘最小操作单元
				超级块--文件系统的信息（系统类型，ionode，各个bitmap信息，data）inode bitmap  ---inode  --data bitmap  ---data
			data：分块存储文件
			inode区：文件分开存放，需要有索引来找到另外的内存块
					inode节点：文件大小fsize，
					文件权限fmode，所属用户user，所属组grop,user,time,addr(存储的每个块号)
					所有的inode节点组成一个inode节点区

					格式化：重新分配inode区
			data bitmap:  标注了哪些数据块未使用
			inode bitmap：标注了哪些inode节点未使用
			超级块：

			存储一个文件的流程：
				1.data bitmap中找到空闲数据块
				2.从inode bitmap 中获取空间inode节点，写入文件详细信息以及数据块信息
				3.将文件目录项写入所在的目录文件中
						目录文件：存放的是一张表--目录下的文件信息（目录项：文件名+inode节点号）
			读取文件流程：cat  a.txt
				通过文件名在目录项中获取到inode节点号，进而在inode区域中获取到inode节点，
				进而获取到文件数据块位置，进而读取到文件数据。

	软链接/硬链接
		ln tmp.txt  tmp.hard
		ln -s tmp.txt tmp.soft
		操作文件，软连接/硬链接 都会改变
		硬链接：跟源文件没有区别，通过相同的inode节点访问到源文件数据   （一个文件别名）
		软链接：是一个单独的文件，通过记录源文件的路径进而访问到源文件数据        （类似于快捷方式）
              		l：符号链接文件(软链接文件)
		1.删除文件：硬链接文件链接数-1，软链接文件失效

		在源文件不需要改变位置的同时，在需要该文件的地方创建软链接文件也能够访问
		2.软链接文件可以跨分区建立，硬链接不可以（每个分区都有自己的inode节点，硬链接无法访问到源文件的inode节点）
		3.软链接文件可以对目录创建，硬链接不可以（目录的唯一的）

	动态库/静态库：生成+使用
		库文件：打包了大量机器代码的文件---供别人的程序使用
		静态库：
			创建： 命名：lib是前缀，.a是后缀，中间是库名称
					gcc -c b.c -o b.o
					ar -cr libmytest.a b.o
					ar:打包静态库的命令     -c  创建    -r  模块替换
			使用：  	在linux下库文件只有被放入指定路径下，才能被找到：/lib /lib64 /usr/lib /usr/lib64
						1.向/etc/ld.so.conf.d 添加配置文件，在配置文件中添加库的搜索路径
						2.将库文件直接放到指定路径下
						3.设置环境变量;LIBRATY_PATH     库的搜索路径环境变量
						  设置环境变量;LD_LIBRATY_PATH  程序运行时库的加载路径环境变量
						4.使用gcc的-L选项指定库的链接搜索路径
							gcc -L 用于指定库的链接搜索路径    -l 指定链接库名称
							gcc a.c -o main -L . -lmytest
							通常用户链接一个操作系统没有自带的库，都会链接静态库，
							用户喜欢使用-L指定库的链接搜索路径，因为程序链接静态库不需要依赖静态库存在，因此可以不用拷贝到/lib下，因为没有其他程序使用这个第三方库，因此也不用考虑代码冗余的问题
						链接静态库不需要使用静态链接   -static  只需要保证指定路径下只有静态库，链接器优先去指定的路径下去找
		动态库：运行时库/共享库      gcc默认是动态库

			创建：   命名：  lib是前缀，.so是后缀，中间是库名称
				gcc -c b.c -o b.o

				gcc -fPIC -c b.c -o b.o    将每个c语言代码编译成自己的目标代码
				gcc --share b.o -o libmytest.so   将所有的目标代码合到一起生成动态库
				-fPIC：编译选项--产生位置无关代码
				--share： 链接选项--将所有的目标代码链接到一起生成动态库而不是生成可执行程序
			    加载到内存中只需要加载一次
			使用：

	虚拟地址空间：是进程之间相互独立，所以通信变得困难,需要有公共介质来相互访问
二
	进程间通信：操作系统为用户提供的几种进程间通信方式
		基本介绍：
			进程之间相互独立，所以互相通信变得困难，无法直接沟通，所以操作系统给其提供了一个公共的
		媒介来进行相互访问。因为通信的场景各有不同，因此操作系统也提供了不同的进程间通信方式
		通信场景：
		    数据传输，数据共性，进程控制，事件通知?
		通信方式：
			管道：传递数据资源--半双工通信（双向选择，单向通信）
				本质：内核中的一块缓冲区
			    匿名管道：
					    进程间实现通信，在内核中创建管道，操作系统返回两个描述符作为管道的操作句柄，
				    对管道的操作就是基础IO操作（提供两个描述符是因为管道是双向选择的）。
				        匿名管道仅能用于具有亲缘关系的进程间通信
					创建：必须将管道创建于创建子进程之前（子进程通过复制父进程获取操作句柄）
			        读写特性：
				        管道中要是没有读写数据，也read会阻塞（一直等待）,若管道中数据满了（65536），
			        则read会阻塞。
				        若管道所有写端被关闭，则read读完数据后返回0（而不是阻塞）（read返回0，表示
				    管道没人写了（写端全部被关闭），没必要再继续读）
				        若管道所有读端被关闭，则write触发异常

					ls | grep make
					因为管道的读写特性，用户在操作管道的时候，最好关闭所有用不到的读写端。
				命名管道：管道有名字--名字的体现方式就是在文件系统中具有一个管道文件
				    管道文件--就是命名管道的名字---给任意进程提供通过打开同一个命名管道
				进而访问到内核中同一块管道缓冲区的功能
				    mkfifo 命令创建命名管道文件
					int mkfifo(const char *pathname,mode_t mode)
					pathname:管道文件的路径名
					mode：   管道文件的操作权限
					返回值：0   失败：-1

					命名管道的打开特性：
						若管道文件没有以写方式打开，则只读打开会阻塞
						若管道文件没有以读
				管道自带同步与互斥（当对管道读写大小小于PIPE_BUF-4096时，保证操作原子性）
				    原子性：操作不可被打断
					同步：对临界资源访问的时序可控性（时序控制--我操作完了别人才能操作）
					互斥：对临界资源的同一时间访问性（保护--我操作的时候别人不能操作）
				管道提供字节流服务--传输方式灵活--造成数据粘连（本质原因：数据之间没有边界）
				管道生命周期随进程

				匿名管道仅能用于具有亲缘关系的进程间通信
				命名管道能用用于任意进程间通信

			共享内存
			消息队列
			信号量






