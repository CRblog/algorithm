utf-8  中文占3个字节
		系统调用IO接口：
			open    O_RDONLY  0_WRONLY O_RDWR | O_CREAT|O_EXCL|O_TRUNC|O_APPEND
			write   read  返回实际读写的长度  lseek   close----------int

			文件描述符和文件流指针
				文件流指针中包含了一个成员变量---文件描述符
				库函数内部封装的就是系统调用接口

			缓冲区：读缓冲区，写缓冲区
				文件流指针中的，系统调用的不需要缓冲区

				缓冲区是用户态的缓冲区，存在于文件流指针结构体中

				文件描述符：系统调用的句柄(是一个数组下标，指向进程中的文件状态信息表中的文件描述信息)
				文件描述符分配规则：最小未使用
				重定向：文件描述符的重定向---改变描述符对应的描述信息，进而改变操作的文件，但是描述符不变

				minishell的重定向: >清空重定向   >>追加重定向
				解析字符串，获取命令名称+参数,在参数中判断是否包含> >>,在重定向符号下一个元素（文件名称）按照相应重定向类型打开文件

						dup2(old,new)

		文件系统：磁盘中的文件管理，以linux下的ext2为例(不止5块)
				每个分区中都有一个文件系统，管理文件
				分页内存管理：分成内存块，每个大小4096
				ps：进程资源使用
				top：CPU资源使用情况
				df：查看磁盘分区资源使用情况
				free：查看内存资源使用情况
				fdisk -l :查看磁盘使用情况
				硬盘接口类型：
						SATA：命名方式：sda
						IDE:
						SCSI:
						NVME: 常用固态硬盘接口类型
				磁盘扇区大小：硬盘最小操作单元
			超级块--文件系统的信息（系统类型，ionode，各个bitmap信息，data）inode bitmap  ---inode  --data bitmap  ---data
			data：分块存储文件
			inode区：文件分开存放，需要有索引来找到另外的内存块
					inode节点：文件大小fsize，
					文件权限fmode，所属用户user，所属组grop,user,time,addr(存储的每个块号)
					所有的inode节点组成一个inode节点区

					格式化：重新分配inode区
			data bitmap:  标注了哪些数据块未使用
			inode bitmap：标注了哪些inode节点未使用
			存储一个文件的流程：
				1.data bitmap中找到空闲数据块
				2.从inode bitmap 中获取空闲inode节点，写入文件详细信息以及数据块信息
				3.将文件目录项写入所在的目录文件中
						目录文件：存放的是一张表--目录下的文件信息（目录项：文件名+inode节点号）
			读取文件流程：cat  a.txt
				通过文件名在目录项中获取到inode节点号，进而在inode区域中获取到inode节点，
				进而获取到文件数据块位置，进而读取到文件数据。

	软链接/硬链接
		ln tmp.txt  tmp.hard
		ln -s tmp.txt tmp.soft
		操作文件，软连接/硬链接 都会改变
		硬链接：跟源文件没有区别，通过相同的inode节点访问到源文件数据   （一个文件别名）
		软链接：是一个单独的文件，通过记录源文件的路径进而访问到源文件数据        （类似于快捷方式）
              		l：符号链接文件(软链接文件)
		1.删除文件：硬链接文件链接数-1，软链接文件失效

		在源文件不需要改变位置的同时，在需要该文件的地方创建软链接文件也能够访问
		2.软链接文件可以跨分区建立，硬链接不可以（每个分区都有自己的inode节点，硬链接无法访问到源文件的inode节点）
		3.软链接文件可以对目录创建，硬链接不可以（目录的唯一的）

	动态库/静态库：生成+使用
		库文件：打包了大量机器代码的文件---供别人的程序使用
		静态库：
			创建： 命名：lib是前缀，.a是后缀，中间是库名称
					gcc -c b.c -o b.o                 
					ar -cr libmytest.a b.o
					ar:打包静态库的命令     -c  创建    -r  模块替换
			使用：  	在linux下库文件只有被放入指定路径下，才能被找到：/lib /lib64 /usr/lib /usr/lib64
						1.向/etc/ld.so.conf.d 添加配置文件，在配置文件中添加库的搜索路径
						2.将库文件直接放到指定路径下
						3.设置环境变量;LIBRATY_PATH     库的搜索路径环境变量
						  设置环境变量;LD_LIBRATY_PATH  程序运行时库的加载路径环境变量
						4.使用gcc的-L选项指定库的链接搜索路径
							gcc -L 用于指定库的链接搜索路径    -l 指定链接库名称
							gcc a.c -o main -L . -lmytest
							可执行程序生成时，库的链接搜索路径：
							可执行程序运行时，库的运行加载路径:   /lib/lib64 /usr/lib   /usr/lib64
							通常用户链接一个操作系统没有自带的库，都会链接静态库，
							用户喜欢使用 -L指定库的链接搜索路径，因为程序链接静态库不需要依赖静态库存在，因此可以不用拷贝到/lib下，因为没有其他程序使用这个第三方库，因此也不用考虑代码冗余的问题
						链接静态库不需要使用静态链接   -static  只需要保证指定路径下只有静态库，链接器优先去指定的路径下去找
		动态库：运行时库/共享库      gcc默认是动态库

			创建：   命名：  lib是前缀，.so是后缀，中间是库名称
				gcc -c b.c -o b.o

				gcc -fPIC -c b.c -o b.o    将每个c语言代码编译成自己的目标代码
				gcc --share b.o -o libmytest.so   将所有的目标代码合到一起生成动态库
				-fPIC：编译选项--产生位置无关代码
				--share： 链接选项--将所有的目标代码链接到一起生成动态库而不是生成可执行程序
			    加载到内存中只需要加载一次
			使用：

	虚拟地址空间：是进程之间相互独立，所以通信变得困难,需要有公共介质来相互访问
二
	进程间通信：操作系统为用户提供的几种进程间通信方式
		基本介绍：
			进程之间相互独立，所以互相通信变得困难，无法直接沟通，所以操作系统给其提供了一个公共的
		媒介来进行相互访问。因为通信的场景各有不同，因此操作系统也提供了不同的进程间通信方式
		通信场景：
		    数据传输，数据共性，进程控制，事件通知?
		通信方式：
			管道：传递数据资源--半双工通信（双向选择，单向通信）
				本质：内核中的一块缓冲区
			    匿名管道：
					    进程间实现通信，在内核中创建管道，操作系统返回两个描述符作为管道的操作句柄，
				    对管道的操作就是基础IO操作（提供两个描述符是因为管道是双向选择的）。
				        匿名管道仅能用于具有亲缘关系的进程间通信
					创建：必须将管道创建于创建子进程之前（子进程通过复制父进程获取操作句柄）
			        读写特性：
				        管道中要是没有读写数据，也read会阻塞（一直等待）,若管道中数据满了（65536），
			            则read会阻塞。
				        
						若管道所有写端被关闭，则read读完数据后返回0（而不是阻塞）（read返回0，表示
				        管道没人写了（写端全部被关闭），没必要再继续读）
				        
						若管道所有读端被关闭，则write触发异常

					ls | grep make
					因为管道的读写特性，用户在操作管道的时候，最好关闭所有用不到的读写端。
				命名管道：管道有名字--名字的体现方式就是在文件系统中具有一个管道文件
				    管道文件--就是命名管道的名字---给任意进程提供通过打开同一个命名管道
				进而访问到内核中同一块管道缓冲区的功能
				    mkfifo 命令创建命名管道文件
					int mkfifo(const char *pathname,mode_t mode)
					pathname:管道文件的路径名
					mode：   管道文件的操作权限
					返回值：0   失败：-1

					命名管道的打开特性：
						若管道文件没有以写方式打开，则只读打开会阻塞
						若管道文件没有以读
				管道自带同步与互斥（当对管道读写大小小于PIPE_BUF-4096时，保证操作原子性）
				    原子性：操作不可被打断
					同步：对临界资源访问的时序可控性（时序控制--我操作完了别人才能操作）
					互斥：对临界资源的同一时间访问性（保护--我操作的时候别人不能操作）
				管道提供字节流服务--传输方式灵活--造成数据粘连（本质原因：数据之间没有边界）
				管道生命周期随进程

				匿名管道仅能用于具有亲缘关系的进程间通信
				命名管道能用用于任意进程间通信

			共享内存---最快的进程间通信方式
				管道：数据放入buffer相当于数据拷贝，读写相当于拷贝两次
				原理：申请一块物理内存空间，将这块物理内存映射连接到进程的虚拟地址空间进行操作；
					   若多个进程映射连接同一块物理内存，则通过这块物理内存实现进程间通信
					   这种通信相较于其他进程间通信方式，少了两步用户态和内核态之间的数据拷贝过程
				共享内存的生命周期随内核
				操作步骤：
					1.创建共享内存                            shmget   ----shell mem get
					2.将共享内存映射连接到虚拟地址空间        shmat
					3.直接通过虚拟地址进行内存操作---memcpy
					4.解除映射连接关系                        shmdt                   delete
					5.删除共享内存                            shmct    ---shell  mem  contrl
				进程间通信方式的命令操作：
					查看： ipcs         -m         -q          -s
					删除： ipcrm -m   shmid   （使用标识符删除）
					     并不会直接删除，等到映射链接数变成0才会删除,在这期间，拒绝后续其他进程的新的映射连接
			消息队列
			    特性：
			    原理：
			信号量
			    原理：内核中的一个计数器，用于资源计数
				    没有资源   则等待（死等）
					一旦有资源  则唤醒（等待队列上的进程）
				功能：实现进程间同步与互斥
				      通过计数器对资源进程计数
					  获取资源通过计数判断是否有资源，没有资源则等待；否则返回，获取资源进行处理  资源数-1
					  如果产生数据，则资源计数+1,唤醒等待队列中的进程
            P/V   原语：   p  -1  +  阻塞
			               对临界资源进行操作
						   v  +1  +  唤醒 
						   
	进程信号：
		信号介绍：
			概念：是一个软件中断（软中断）,通知进程发生了某个事件，打断当前操作，去处理这个事件
		信号种类：
			信号有很多种类，每个信号都代表一个事件（操作系统）
			查看：   kill -l
			62 种信号 前31种是UNIX保留下来的，SIGUSR1,SIGUSR2是为用户使用的，后面的
		生命周期：
			信号产生：
			    硬件产生：
					ctrl+c    ctrl+z    ctrl+|
				软件产生：
				    kill命令      kill(pid,sig)   raise(sig)   abort alarm(sec) signqueue
			core dumped:核心转储
				ulimit -a 查看
				ulimit -c 设置core文件最大大小 单位是kb     ulimit -c 1024
				gdb ./main -> core-file core.pid ->bt
			信号在进程中注册：
			    在pcb的struct sigpending->signal中标记收到了哪些信号;并且为这个信号组织一个
				sigqueue节点，添加到链表中
				可靠信号：34-64 修改位图为1，并且为每个到来的信号都添加一个sigqueue节点
						
				非可靠信号：1-31 判断位图是否为1，为1则什么都不做（事件丢失）否则添加节点修改位图
				
			信号在进程中注销：在处理信号之前，在PCB中擦掉信号存在的痕迹
				删除节点：位图置0
				可靠信号：删除节点后，判断是否还有相同节点，如果有，位图置为1，没有则置为0
				可靠信号：删除节点后，位图置为0（因为非可靠信号节点只会有一个。）
			信号处理：
			   信号的递达 
			   默认处理：操作系统中既定义好的信号处理方式
					SIG_DFL：默认处理方式
					SIG_IGN: 忽略处理方式
			   忽略处理：忽略，什么都不做
			   自定义处理：用户自己定义处理方式
			   
			   一个进程因为系统调用/中断/异常从用户态切换到内核状态运行，完成功能后，准备返回用户态的时候，
			   查看是否有信号待处理，如果有，并且是默认/忽略处理方式，则在内核直接完成，若是自定义处理方式
			   则返回用户态调用信号处理函数，完毕之后调用sigreturn返回内核态，当没有信号待处理，则调用
			   sys_return返回用户态主控流程
			   
			   信号的阻塞：组织信号被递达
					在pcb中有一个信号阻塞集合，这个信号阻塞集合的作用就是用于标记，哪些信号到来的时候暂时不被处理
				    先将所有信号阻塞（阻止信号被处理）
					按回车---程序继续运行
					将所有信号解除阻塞
					man  sigprocmask 
					      how:对信号阻塞集合要进行的动作
								SIG_BLOCK       block = block | set     //将set中的信号添加到阻塞集合
								SIG_UNBLOCK     block = block & (~set)   //解除阻塞
								SIG_SETMASK     block = set        //将阻塞集合设置为set中的信号
						  set
						     oldset：  用于保存原来的信号集合
							 SIGKILL -9     SIGSTOP   -18  这两个信号无法被阻塞
		竞态状态：
				程序竞争运行
				函数的可重入/不可重入：
					函数是否可以在多个执行流中重复进入（调用），而不会出现异常问题；
					若有可能出现问题就是不可重入函数；否则就是可重入函数
				函数可重入与不可重入的关键点：是否在函数中对全局函数进行非原子操作
				
				当用户自己设计函数或者调用别人函数的时候就需要考虑函数是否可以重入
				malloc/free 不可重入函数
				
		
						   
						   
						   
						   
						   
						   
						   
						   
						   
						   
			




