编译过程；
    预处理：去掉注释，展开所有代码
    编译：语义语法纠错，将代码解释成为汇编代码
    汇编：将汇编代码解释成为机器代码
    链接：链接代码库以及所有的目标文件，生成可执行程序
    库文件：实现一些常用的功能接口，为了防止每次编译耗费时间，
		此将这些接口代码进行编译汇编，并且将汇编完成的代码存储
		到了一个文件中，这个文件就叫库文件。
		
		如果要用库函数，就需要包含头文件，因为头文件中声明了这个函数的存在
		这时候编译器在头文件中检测到了这个声明，就知道有这个函数。
    最终链接生成可执行程序的时候，因为要具体让cpu处理指令，因此就必须将这些接口
    的具体实现拿出来。
    gcc的链接方式：
        静态链接：静态链接库，链接式，将库中的代码写入到可执行程序中，
                优点：运行时不依赖库的存在
                缺点：占用资源，如果被大量的程序大量的链接，会造成代码冗余
        动态链接：链接动态库，链接时，只记录接口的位置符号信息，并不拷贝代码
                优点：占用资源少，在内存中大量程序中可以共享使用（共享库）
                缺点：运行时需要依赖库的存在（运行时库）
        gdb：调试器
            调试一个程序的前提是什么？
                生成debug版本程序，向程序中添加调试符号信息
                linux下gcc默认生成的程序是release版本程序，需要加上-g选项，生成debug程序
                gcc -g test.c -o test.out
                gdb加载程序
                    gdb  ./test.c
                    gdb  ->file ./test.c
				   获取运行参数，并运行程序
				   r -a -l -s -t   参数以空格形式间隔
            最常见的调试操作有哪些？
                打印内容
                单步调试
                    start 开始逐步调试
                    l   file  ：line（行号）
                    n(next)       下一步（不进入函数，直接将函数运行）
                    s(step)       跟踪进入函数
					until   直接运行到指定行
						until file:line
					
                打断点
					b(break):打断点
						b test.c:line   给文件的多少行打断点
						b function_name  给函数打断点
						info break  查看断点信息
						d(delete) 6    删除第六个断点
						watch 变量名称
						c(continue)     继续开始运行
                找到程序崩溃位置：
                查看函数调用栈信息
						bt     查看函数调用栈，快速定位程序崩溃位置
    常用工具：
    make/makefile:项目自动化构建工具
    makefile:普通文本文件，记录了项目的构建流程规则
    make:一个解释程序，到当前执行make命令的目录下寻找makefile文件，并且队makefile中记录的
    	项目构建规则进行解释执行。
		makefile：编写规则
		    目标对象：依赖对象
			 [tab]命令操作
		make执行规则：
            1.解释执行时，在makefile中寻找目标对象（只寻找第一个目标对象）
			找到目标对象后，执行命令操作
			如果有目标对象，判断目标对象是否存在：
			    如果目标对象不存在：执行命令操作，生成目标对象
			    如果目标对象已存在：判断是否有依赖对象
                        没有依赖对象：直接报错（目标最新）-不需要重新生成
                        如果有依赖对象：
                            判断依赖对象是否存在?
                                存在：通过目标对象和依赖对象的最后一次修改时间判断是否需要重新生成目标对象
                                不存在：make继续在makefile中寻找依赖对象的生成规则，先生成依赖对象，进而再生成目标对象
            预定义变量：
				$@:目标对象
				$^:所有依赖对象
				$<:依赖对象中的第一个
                .PHONY用于声明伪对象：不管目标对象是否存在，是否最新，每次都重新生成
			git:项目版本控制工具
			    svn-集中式   git-分布式版本控制工具
				git add filename
				git commit -m ""
				git push orign master
    
    
    
    
    
    
    
    
    
    
    
    
