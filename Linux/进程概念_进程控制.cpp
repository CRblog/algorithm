20190411-0406复习

	make/makefile
    	在makefile中定义大量项目编译规则流程，在命令行执行make命令，make程序到当前目录下寻
    	找makefile文件，并且对makefile定义好的规则逐条解释执行
    	
    	预定义变量：
			$@:目标对象
			$^:所有的依赖对象
			$<:依赖对象中的第一个
        伪对象：目标对象每次都需要重新执行（不管是否存在，是否最新）
        声明伪对象：.PHONY
	git:
			git clone
			git add
			git commit -m "bak msg"
			git push origin master
    进度条程序：
		\r和\n
		printf(hello)    不带有\n时，数据先被写入缓冲区中，等到缓冲区满了/刷新缓冲区，才会被写入文件
		\n在操作的文件为终端显示文件时，不仅具备换行作用，还有刷新缓冲区的作用（仅仅针对终端显示文件）
    进程概念：
			进程是一个运行中的程序，Linux是一个多任务操作系统，表示有大量的程序需要被cpu调度运行
    	这时候cpu使用了分时技术，分别轮询处理每一个程序，在进程程序切换调度时，需要记录运行信息，
		因此操作系统在调度进程在cpu上运行时，使用pcb对运行中的程序进行描述，通过调度pcb完成对进程
		的调度，因此进程就是pcb。
		（使用pcb描述进程，使用双向链表将pcb串起来进行管理）pcb-task_struct
    操作系统如何通过pcb来完成进程的调度---描述信息：
        内存指针，程序计数器，上下文数据，标识符pid，状态，优先级，IO信息，记账
    查看进程：
        ps   -ef  aux       /proc       getpid()
    守护进程：一个特殊的孤儿进程（脱离终端，脱离登陆对话的孤儿进程）
    
    
    
    
    
    进程的优先级：通过一个评级来决定一个进程的cpu资源优先分配权
        存在的意义：让计算机运行的更加合理(因为进程的性质各有不同---批处理/交互式)
        查看：ps -l   PRI值    NI值
        修改：优先级无法直接修改，但是可以通过修改NI的值来调整PRI的值   PRI = PRI + NI
			renice -n -100 -p 3489    3489：pid值
			nice -n ni_val  ./main            nice值范围：-20~19
			优先级调整更多的是针对cpu密集型程序(对cpu资源要求比较高)
			磁盘密集型程序因为本身对cpu资源要求就不是很高，因此大多数情况下没必要调整
        竞争性：    独立性：    并行：        并发：
        环境变量：保存有设置操作系统运行环境参数的变量
            查看环境变量：env    echo:打印指定变量内容    set
            设置环境变量：export
            删除环境变量：unset
            常见环境变量：HOME SHELL    PATH
        程序地址空间：
            地址：内存区域的编号---进程的虚拟地址空间---内存描述符---mm_struct
            操作系统通过mm_struct这个结构体给进程描述了一个虚拟的地址空间
            
            如何描述：
				mm_struct{
					ulong szie;
					ulong code_start;
					ulong code_end;
					ulong data_start;
					ulong data_end;
				}
				为什么用虚拟地址空间：
                    分段式内存管理：程序管理简单，但是内存使用率不高
                    分页式内存管理：分成默认4K大小的内存页
                    					页号：     业内偏移
                    虚拟内存：页表(记录物理页号)>映射
                    
            虚拟地址空间+页表：提高内存利用率，对内存访问进行控制
            				   保证进程的独立性
            写时拷贝技术：父进程创建了子进程，但是并没有直接给子进程开辟内存，拷贝数据
            ，而是跟父进程映射到同一个位置，但是如果内存中数据发生的改变，那么对于改变
            的这块内存，需要重新给子进程开辟内存，并且更新页表信息
    进程控制：
		fork()----复制，返回值，写时赋值
		
		vfork()---
		    创建子进程，子进程与父进程共用一块虚拟地址空间，为了防止调用栈混乱，因此阻塞父进程
        直到子进程调用exit()退出或者进行替换。
			vfork的子进程不能在main函数中return退出，因为释放资源后，父进程陷入混乱崩溃
			
//			fork vfork clone 三者的区别
			
//			fork和vfork在内核中需要调用clone实现进程的创建
//			fork需要创建虚拟地址空间和页表，vfork不需要，所以传参稍有不同
    进程终止：进程退出
            进程退出的场景：
                正常退出，结果符合预期
                正常退出，结果不符合预期
                异常退出
            终止方式：main函数中return ;  exit(int statu)  _exit(int statu)
                exit库函数，退出时刷新缓冲区
                _exit系统调用接口，退出时，不会刷新缓冲区，直接释放资源
                
				char *strerror(int errnum)//通过错误编号获取描述信息
				perror("fork error");
				printf("fork error :%s\n",strerror(errno));
    进程等待：等待子进程退出---为了避免产生僵尸进程
			pid_t wait(int status)   ---阻塞等待任意一个子进程退出
//			阻塞：发起一个系统调用完成功能，当前如果不具备完成条件，则等待，直到完成功能后返回，
//			非阻塞：如果当前不具备完成条件，则立即报错返回

        核心转储：程序异常退出时，保存程序运行信息
    程序替换：替换一个进程所正在运行的程序-----重新加载其他程序到内存，映射进程虚拟地址空间与内存
    的映射位置到新的程序地址上（代码段修改映射位置，数据段重新初始化）  进程重新从main函数开始调度运行
    
        如何进行程序替换：
			execl       execlp      execle
			execv       execvp      execve
			l和v的区别：传参的区别，
						l是程序运行参数使用函数的实参平铺的形式赋予  execl(ls,ls,-l,-a,NULL)
						v是程序运行参数使用字符串指针数组赋予，     argv[0] = ls argv[1] = -1  execl(ls,argv);
            带p和不带p的区别：
                带P：程序名称可以不带路径，直接去PATH环境变量所指定的路径下找程序
						execlp(ls,...)
                不带P：程序名称必须带路径   execl(/bin/ls,...);
			d带e与不带e的区别：
                带e：给进程自定义环境变量       env[0] = "myenv = 100"execle(ls,...,NULL,env)
                不带e：继承原有默认的环境变量   execl(ls,...)
